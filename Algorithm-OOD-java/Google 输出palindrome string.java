用一个int32（可以看成是一个32位bool数组）记录每一个char是否出现过，然后开始读input，如果当前字符没有出现过，
通过位运算在bithash里把这个字符对应的位mark为1表示出现过了；如果该字符出现过，清空该bit，然后加入输出。
读完input之后看我的bithash是否为0，如果不为0，随便拿出一个mark了的bit对应的char append到输出，否则跳过这步。
最后一步是翻转现在的输出串（要注意一下，如果之前一步加入了某个char，这里要从倒数第二位开始翻转）append到原输出串，操作完成。

看一个样例：
ababca

读到ab之后，这两位在bithash里被mark了；读到第三位a的时候，因为a已经被mark了，所以unmark并且加入输出；第四位b同理；
第五第六位都只在bithash里mark，不加入输出。这时候的输出串是：
ab. 鍥磋鎴戜滑@1point 3 acres
而且bithash不为0。所以这时候我们取出最低位1对应的char加入输出，于是输出变成 abc。由于加入了新字符，所以从倒数第二位开始翻转，于是得到最终输出abcba。

这个做法全程只用一个额外32位int作为hash，是原本开 int hash[26]的1/26。
